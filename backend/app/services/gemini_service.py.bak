import os
import google.generativeai as genai
from typing import Dict, List, Optional, Tuple
import json
import time

class GeminiService:
    def __init__(self):
        api_key = os.getenv('GEMINI_API_KEY')
       def generate_response(self, query: str, products: List[Dict]) -> str:
        """Generate a sales-focused response based on the query and matching products."""
        try:
            prompt = f'''You are a helpful fashion retail sales assistant. Based on the available products, create a friendly response.

Customer query: {query}

Available products:
{json.dumps(products, indent=2)}

Generate a response that:
1. Shows understanding of the customer's needs
2. Recommends relevant products with features and benefits
3. Suggests styling options when appropriate
4. Offers personalized advice
5. Encourages further engagement
6. Keeps a helpful, professional tone

Keep the response natural and engaging. Focus on helping the customer make the best choice.'''         raise ValueError("GEMINI_API_KEY environment variable is not set")
        
        try:
            # Initialize the Gemini client
            genai.configure(api_key=api_key)
            
            # List available models to find the best one
            available_models = []
            for m in genai.list_models():
                if 'generateContent' in m.supported_generation_methods:
                    available_models.append(m.name)
            
            # Define preferred models with their full names
            model_preferences = [
                'models/gemini-1.5-pro',  # Stable model
                'models/gemini-pro',      # Fallback
                'models/gemini-1.5-pro-latest'  # Latest stable
            ]
            
            # Find first available model from our preferences
            selected_model = None
            for model_name in model_preferences:
                if model_name in available_models:
                    selected_model = model_name
                    break
            
            if not selected_model:
                print("No compatible Gemini model found")
                self.model = None
                return
                
            print(f"Using model: {selected_model}")
            self.model = genai.GenerativeModel(selected_model)
            
            # Test the model
            response = self.model.generate_content("Test")
            if not response or not hasattr(response, 'text'):
                raise ValueError("Model test failed")
                
        except Exception as e:
            print(f"Error initializing Gemini service: {str(e)}")
            self.model = None
            
        # Define sales-focused system prompt
        self.system_prompt = '''You are a knowledgeable fashion retail sales assistant. Help customers find perfect clothing items by understanding their needs and context.

Understand these aspects of customer queries:
1. Occasion/Event with suggested categories:
- Wedding/Marriage/Ceremony  formal style (suggest: dresses, formal outerwear)
- Party/Celebration/Cocktail  party style (suggest: dresses, trendy tops)
- Office/Work/Business  business style (suggest: tops, bottoms, blazers)
- Daily/Casual/Weekend  casual style (suggest: comfortable tops, bottoms)

2. Categories:
- Tops: shirts, t-shirts, blouses, crop tops
- Bottoms: pants, jeans, skirts, shorts
- Dresses: gowns, dresses
- Outerwear: jackets, coats, sweaters, cardigans

3. Additional Attributes:
- Colors: black, white, red, blue, green, yellow, pink, purple, brown, gray
- Styles: casual, formal, party, business, sporty, vintage, bohemian
- Price Range: extract any mentioned budget

Return structured JSON with these fields (use null if not specified):
{
    "category": string,  // "tops", "bottoms", "dresses", "outerwear"
    "style": string,    // "casual", "formal", "party", "business", "sporty", "vintage", "bohemian"
    "color": string,    // any color mentioned
    "price_range": {
        "min": number,  // minimum price, null if not specified
        "max": number   // maximum price, null if not specified
    }
}'''

    def parse_query(self, user_message: str) -> Dict:
        """Parse user query and extract relevant product filters"""
        # If Gemini service is not available, use simple keyword matching
        if not self.model:
            return self._fallback_parse_query(user_message)
            
        try:
            # Add retry mechanism
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    # Combine system prompt with user message
                    prompt = f"{self.system_prompt}\n\nUser query: {user_message}\nExtract product filters:"
                    
                    # Generate response
                    response = self.model.generate_content(prompt)
                    
                    # Extract JSON from response
                    response_text = response.text.strip()
                    # Find JSON content between curly braces
                    start = response_text.find('{')
                    end = response_text.rfind('}') + 1
                    if start >= 0 and end > start:
                        json_str = response_text[start:end]
                        return json.loads(json_str)
                    
                    # If no valid JSON found, use fallback
                    return self._fallback_parse_query(user_message)
                    
                except json.JSONDecodeError:
                    if attempt < max_retries - 1:
                        time.sleep(1)  # Wait before retry
                        continue
                    print(f"Failed to parse JSON response: {response_text}")
                    return self._fallback_parse_query(user_message)
                    
                except Exception as e:
                    if attempt < max_retries - 1:
                        time.sleep(1)  # Wait before retry
                        continue
                    print(f"Error in parse_query: {str(e)}")
                    return self._fallback_parse_query(user_message)
                    
        except Exception as e:
            print(f"Unexpected error in parse_query: {str(e)}")
            return self._fallback_parse_query(user_message)

    def _fallback_parse_query(self, user_message: str) -> Dict:
        """Simple keyword-based fallback for when Gemini is unavailable"""
        filters = {}
        message = user_message.lower()
        
        # Occasion/Event mapping to styles with category suggestions
        occasions = {
            'formal': {
                'keywords': ['wedding', 'marriage', 'ceremony', 'formal', 'engagement', 'reception'],
                'categories': ['dresses', 'outerwear'],
                'style': 'formal'
            },
            'party': {
                'keywords': ['party', 'celebration', 'festival', 'club', 'birthday', 'cocktail'],
                'categories': ['dresses', 'tops'],
                'style': 'party'
            },
            'business': {
                'keywords': ['office', 'work', 'business', 'professional', 'meeting', 'interview'],
                'categories': ['tops', 'bottoms', 'outerwear'],
                'style': 'business'
            },
            'casual': {
                'keywords': ['daily', 'casual', 'regular', 'everyday', 'weekend', 'shopping'],
                'categories': ['tops', 'bottoms'],
                'style': 'casual'
            },
            'sporty': {
                'keywords': ['sport', 'gym', 'workout', 'exercise', 'fitness', 'training'],
                'categories': ['tops', 'bottoms'],
                'style': 'sporty'
            }
        }
        
        # Check for occasions and apply style + suggested categories
        for occasion, data in occasions.items():
            if any(keyword in message for keyword in data['keywords']):
                filters['style'] = data['style']
                # If no specific category mentioned, suggest first category from occasion mapping
                if 'category' not in filters and data['categories']:
                    filters['category'] = data['categories'][0]
                break
        
        # Category detection with expanded keywords
        categories = {
            'tops': ['top', 'shirt', 'blouse', 't-shirt', 'tee', 'crop'],
            'bottoms': ['pants', 'jeans', 'skirt', 'shorts', 'trouser', 'legging'],
            'dresses': ['dress', 'gown', 'maxi', 'midi', 'mini'],
            'outerwear': ['jacket', 'coat', 'sweater', 'cardigan', 'hoodie', 'blazer']
        }
        for category, keywords in categories.items():
            if any(keyword in message for keyword in keywords):
                filters['category'] = category
                break
        
        # Style detection
        styles = ['casual', 'formal', 'party', 'business', 'sporty', 'vintage']
        for style in styles:
            if style in message:
                filters['style'] = style
                break
        
        # Color detection
        colors = ['black', 'white', 'red', 'blue', 'green', 'yellow', 'pink', 'purple', 'brown', 'gray']
        for color in colors:
            if color in message:
                filters['color'] = color
                break
        
        # Price range detection
        import re
        price_matches = re.findall(r'under\s*(\d+)|below\s*(\d+)|(\d+)\s*-\s*(\d+)', message)
        if price_matches:
            filters['price_range'] = {}
            if price_matches[0][0] or price_matches[0][1]:  # "under X" or "below X"
                max_price = int(price_matches[0][0] or price_matches[0][1])
                filters['price_range'] = {'min': None, 'max': max_price}
            elif price_matches[0][2] and price_matches[0][3]:  # "X - Y"
                min_price = int(price_matches[0][2])
                max_price = int(price_matches[0][3])
                filters['price_range'] = {'min': min_price, 'max': max_price}
        
        return filters

    def generate_response(self, query: str, products: List[Dict]) -> str:
        """Generate a sales-focused response based on the query and matching products."""
        try:
            prompt = f"""Act as a helpful fashion retail sales assistant. Based on the customer's query and available products, create a friendly and helpful response.

Customer query: {query}

Available products:
{json.dumps(products, indent=2)}

Generate a response that:
1. Acknowledges and shows understanding of the customer's needs
2. Provides relevant product recommendations with key features and benefits
3. Suggests styling options and complementary items if applicable
4. Offers personalized advice based on the query context
5. Encourages further engagement (e.g., asking for preferences, suggesting alternatives)
6. Maintains a helpful, professional tone

Keep the response natural and engaging. Focus on helping the customer make the best choice.
"""
            response = self.model.generate_content(prompt)
            return response.text
            
        except Exception as e:
            print(f"Error generating response: {str(e)}")
            return "I apologize, but I'm having trouble processing your request right now. Please try again later."
